#+TITLE: Currificación
* Conceptos
  #+BEGIN_QUOTE
  Clojure por defecto no aplica *currificación*, pero podemos usar la función ~partial~ para lograr un comportamiento similar
  #+END_QUOTE
* Apply
** Conceptos
** Ejemplos
*** Ejemplos Básicos
**** Ejemplo 1 - Aplicar la función Max a un vector
     #+BEGIN_SRC clojure
       ;; max
       ;; - espera uno ó mas parámetros (usa el concepto de número indefinido de parámetros, el rest parameter)
       ;; - no espera recibir un vector con valores
       (max 1 2 10)

       ;; esto no funcionaría como se espera..
       (max [1 2 10])

       (apply max [1 2 10])
     #+END_SRC
**** Ejemplo 2 - Aplicar funciones básicas
     #+BEGIN_SRC clojure
       (apply + '(1 2))
       ;; es lo mismo que (+ 1 2)

       (apply + [1 2 3 4])
       (apply + 1 [2 3 4])
       ;; es lo mismo que (+ 1 2 3 4)

       (apply str ["a" "b" "c"])
       (apply str "a" ["b" "c"])
       ;; es lo mismo que (str "a" "b" "c")
     #+END_SRC
*** Ejemplos Interesantes
**** Ejemplo 1
     #+BEGIN_SRC clojure
       (conj [0] 1 2 3)
       (into [0] [1 2 3])

       ;; - into inserta en una estructura (1º param) los elementos de otra estructura (2º param)
       ;; - conj inserta en una estructura (1º param) uno ó mas valores individuales (2º3º..nº parámetro, rest parameter)
       ;; - apply aplica una función (1º param) a uno ó más parámetros (suponiendo que esa función espera esos parámetros)
       ;;
       ;; con apply aplicamos la función conj a los siguientes parámetros que conj esperaría
       (defn my-into
         [estructura-destino elementos-estructura-origen]
         (apply conj estructura-destino elementos-estructura-origen))

       (my-into [0] [1 2 3])
     #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://clojuredocs.org/clojure.core/apply][apply - clojure.core (clojuredocs.org)]]
* Partial
** Conceptos
** Ejemplos
*** Ejemplos Básicos
**** Ejemplo 1 - Devolver una función que usa la función conj
     #+BEGIN_SRC clojure
       (def agregar-palabras-claves
         (partial conj ["articulo" "blog"]))

       (agregar-palabras-claves "noticias" "programación" "it")

       ;; a modo recordatorio de como usar conj
       (conj [] 1 2 3)
     #+END_SRC
**** Ejemplo 2
     #+BEGIN_SRC clojure
       ;; add10 devuelve una función (+ 10) y que espera cero, uno ó mas parámetros
       ;; la idea es pasarle sólo 1, pero lo importante es que devuelve una función y espera recibir parámetros
       (def add10 (partial + 10))
       (add10 5)

       ;; alternativas al anterior aunque estos esperan sólo 1 parámetro
       ;; definimos una función nombrada
       (defn add2 [n] (+ n 2))
       (add2 5)

       ;; - bindeamos/vinculamos a add5 una función anónima (ó también podriamos decir que nombramos una función anónima)
       ;; - add5 devuelve una función anónima que espera un parámetro
       (def add5 (fn [n] (+ n 5)))
       (add5 10)

       ;; usamos una función anónima abreviada de la forma #()
       ;; add3 devuelve una función anónima que espera un parámetro
       (def add3 #(+ 3 %))
       (add3 5)
     #+END_SRC
*** Ejemplos Interesantes
**** Ejemplo 1 - Implementando la función partial
     #+BEGIN_SRC clojure
       (defn my-partial
         "Recibe una función seguido de uno ó más parámetros (parameter rest) y devuelve una función anónima,
         la función anónima recibe uno o más paraḿetros (parameter rest) y se los pasa a la primera función"
         [funcion-parcial & parametros]
         (fn [& parametros-adicionales]
           (apply funcion-parcial (into parametros parametros-adicionales))))

       (def add10 (my-partial + 10))
       (add10 5)

       (comment "
       (def add10 (partial + 10))
       (add10 5)

       (apply max [1 2 3 4])
       ")
     #+END_SRC
** TODO Referencias
  #+BEGIN_COMMENT
  Seguir desarrollando usando como base estas referencias
  #+END_COMMENT
*** Referencias Extraoficiales
    1. [[http://xahlee.info/clojure/clojure_function_currying.html][Clojure Partial Function, Currying (xahlee.info)]]
    2. [[https://practical.li/clojure/thinking-functionally/partial-functions.html][Currying & Partial Functions (practical.li)]]
