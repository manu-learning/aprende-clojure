* Intro
  #+BEGIN_QUOTE
  Algunas de las funciones más utilizo en ClojureScript (/por el momento/)
  #+END_QUOTE
* Atomos (Atom)
** Conceptos
   - la función ~atom~ crea y devuelve un tipo de dato *Atom* al que se lo puede bindear/vincular a una variable
   - el tipo de dato devuelto ~atom~ es *mutable*, por tanto aplican las mismas operaciones que con los *tipos primitivos*
   - la función ~defer~ recupera el valor de un átomo
   - ~@~ es la forma corta de ~defer~
     (similar a cuando usamos la macro ~#~ para acortar una *función anónima*)

   #+BEGIN_QUOTE
   El objetivo de ~atom~ es persistir datos en una *estructura inmutable* como lo es ~map~

   El *estado* de un átomo se lo suele representar con un estructura ~map~
   #+END_QUOTE
** Modificar un átomo con Swap!
   - ~swap!~ cambia el estado de *forma atómica* de un ~atom~
     (/aunque debemos pasarle la función que aplicará el cambio de estado/)
   - ~swap!~ es *thread-safe* por tanto asegura que aplicará cambios evitando una *condición de carrera*
   - los parámetros que recibe son
     1) el 1º parámetro es el átomo
     2) el 2º parámetro es la función que aplicará sobre el valor del átomo

   #+BEGIN_QUOTE
   Internamente la función ~swap!~ opera de la siguiente manera
   1. lee el valor actual que se referencia
   2. aplica la función en el valor
   3. intenta ejecutar la función ~compare-to-set~ (función de más bajo nivel)
   #+END_QUOTE
** Modificar un átomo con Reset!
   - ~reset!~ cambia el valor inicial de un átomo (ó bien de un nombre que referencia a un tipo de dato ~atom~)

   #+BEGIN_QUOTE
   Usarlo podría ser una MALA PRÁCTICA,
   porque no tiene la característica de *thread-safe* por tanto podría existir *condición de carrera*
   #+END_QUOTE
** Ejemplos
*** Ejemplos Básicos
**** Ejemplo 1 - Crear un átomo con atom y Recuperar su valor con @
     #+BEGIN_SRC clojure
       (def mi-atomo (atom 40))

       ;; defer
       ;; - recuperar el valor del átomo ó desreferenciar el átomo
       (deref mi-atomo)

       ;; el @ es la forma corta de defer
       @mi-atomo
     #+END_SRC
**** Ejemplo 2 - Modificar el valor de un átomo con swap!
     #+BEGIN_SRC clojure
       (def mi-atomo (atom 40))

       ;; le pasamos la función (inc) que incrementa en 1
       ;; en éste caso cada vez que evaluamos la expresión, el valor del átomo incrementará en 1 (41,42,..)
       (swap! mi-atomo inc)

       ;; le pasamos la función + y el valor que le sumará al valor del átomo
       ;; en éste caso cada vez que evaluamos la expresión, el valor del átomo incrementará en 2
       (swap! mi-atomo + 2)

       (swap! mi-atomo - 2)

       ;; otra forma sería pasarle una funcion anónima
       (swap! mi-atomo (fn [x] (+ x 2)))
     #+END_SRC
**** Ejemplo 3 - Establecer un nuevo valor inicial al átomo con reset!
     #+BEGIN_SRC clojure
       (def mi-atomo (atom 40))

       ;; reset!
       ;; - cambiar el valor actual del átomo por uno nuevo
       (reset! mi-atomo 0)
     #+END_SRC
*** Ejemplos
**** Ejemplo 1 - Crear un átomo con una estructura map
     #+BEGIN_SRC clojure
       ;; bindeamos/vinculamos a la variable auto un átomo que contiene una estructura map
       (def auto
         (atom {:modelo "Audi"
                :velocidad 10
                :precio 500}))

       ;; desreferenciamos el átomo vinculado/bindeado a la variable auto
       ;; y devolverá la estructura map
       @auto

       ;; con assoc devolvemos una nueva estructura map con la velocidad cambiada
       ;; (si evaluamos @auto el valor seguirá siendo 10)
       (assoc @auto :velocidad 25)

       ;; con swap cambiamos de forma atómica el estado del átomo,
       ;; acá le pasamos una función que cambia el valor de la keyword velocidad a 50
       (swap! auto
              assoc :velocidad 50)

       ;; cambiamos los valores iniciales  del átomo
       ;; (OJO, se considera una mala práctica, porque no tiene la característica de thread-safe por tanto podría existir condición de carrera)
       (reset! auto
              {:modelo "" :velocidad 0 :precio 0})

       ;; para recordar la función assoc
       ;; - devuelve una nueva estructura map
       ;; - asocia a una estructura map un elemento del tipo :clave valor
       ;; - modifica un elemento :clave valor del map, si éste está incluído

       ;; agregamos a un map vacío {} la keyword :velocidad con el valor 10
       (assoc {} :velocidad 10)

       ;; modificamos la keyword velocidad de 10 a 0
       (assoc {:velocidad 10} :velocidad 0)
     #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://clojure.org/reference/atoms][Reference, Atoms (clojure.org)]]
    2. [[https://clojuredocs.org/clojure.core/atom][atom, clojure.core (clojuredocs.org)]]
    3. [[https://clojuredocs.org/clojure.core/swap!][swap! clojure.core (clojuredocs.org)]]
    4. [[https://clojuredocs.org/clojure.core/reset!][reset! clojure.core (clojuredocs.org)]]
*** Referencias Extraoficiales
    1. [[https://www.tutorialspoint.com/clojure/clojure_atoms_swap.htm][Atom and swap! (tutorialspoint.com)]]
    2. [[https://emanuelpeg.blogspot.com/2022/01/concurrencia-en-clojure.html][Concurrencia en Clojure (by Emanuel Goette)]]
    3. [[https://ericnormand.me/mini-guide/atom-code-explanation][Atom code explanation (ericnormand.me)]]
* Secuencia de Keys y Vals
** Ejemplo
  #+BEGIN_SRC clojure
    ;; vals
    ;; - devuelve una secuencia de valores de una estructura map (en el mismo orden)
    (vals {:nombre "carlitos" :edad 19})


    ;; keys
    ;; - devuelve una secuencia de keywords de una estructura map (en el mismo orden)
    (keys {:nombre "carlitos" :edad 19})
  #+END_SRC
* Operaciones sobre estructuras Map Anidadas (Nested Map)
** Conceptos
  - ~get-in~ y ~update-in~ acceden a una *estructura map* con 1 ó varios *niveles de anidamiento*
  - acceden a los elementos del map con ~keywords~ dentro de un vector ~[:a]~
    (Ej. ~get-in participante [:usuario]~)
  - si la *estructura map tiene varios niveles de anidamiento*, se *encadenan las keywords* ~:a :b :c~
    (Ej. ~get-in participante [:usuario :perfil :ciudad]~)
  - si la *estructura map contiene un vector*, se debe indicar la posición del elemento en el vector ~:a 0~
    (Ej. ~get-in participante [:usuario :amigos 0 :nombre]~)
** get-in
  - ~get-in~ devuelve un elemento de la estructura map
** update-in
  - ~update-in~ devuelve una nueva estructura anidada con el valor modificado asociado a la keyword
** Ejemplos
*** Ejemplo 1 - Obteniendo valores con get-in
#+BEGIN_SRC clojure
  (def cuenta {:usuario "carlitos"
               :perfil {:nombre "carlitos"
                        :direccion {:ciudad "Buenos Aires" :barrio "Belgrano"}}})

  (get-in cuenta [:perfil :direccion :ciudad])

  (def gary {:usuario "Gary"
             :clase "Entrenador"
             :pueblo "Paleta"
             :rivales ["Ash"]
             :pokemones [{:nombre "Pikachu" :tipo "electrico"}
                         {:nombre "Charmander" :tipo "fuego"}
                         {:nombre "Raichu" :tipo "electrico"}]})

  ;; accedemos al string
  (get-in gary [:pueblo])

  ;; accedemos a un vector de estructuras map,
  ;; luego al primer elemento del vector,
  ;; el resultado será una estructura map
  (get-in gary [:pokemones 0])

  ;; accedemos a un vector de estructuras map,
  ;; luego al primer elemento del vector,
  ;; luego el valor de la keyword :nombre
  ;; el resultado será valor asociado a la keyword
  (get-in gary [:pokemones 0 :nombre])
#+END_SRC
*** Ejemplo 2 - Actualizando valores asociados a una keyword con update-in
#+BEGIN_SRC clojure
  (def cuenta {:usuario "carlitos"
               :edad 18
               :perfil {:nombre "carlitos"
                        :direccion {:ciudad "Buenos Aires" :barrio "Belgrano"}}})

  ;; modificamos el valor de la keyword :edad con la función incremento (inc)
  ;; el parámetro que recibe (inc) será el valor asociado a la keyword :edad
  (update-in cuenta [:edad] inc)

  ;; modificamos el valor keyword :edad con la función resta (-)
  ;; los parámetros a la función (-)
  ;; 1º parámetro el 5
  ;; 2º parámetro el valor asociado a la keyword
  (update-in cuenta [:edad] - 5)

  ;; verificamos que la estructura original no se modificó
  (get-in cuenta [:edad])
#+END_SRC
* TODO constantly
** Conceptos
  - ~constantly~ devuelve una función que recibe 1 ó más parámetros y devuelve siempre el primero
** Ejemplo
#+BEGIN_SRC clojure
  (def diez (constantly 10))

  (diez 5)
  (diez "hola")
  (diez (+ 1 1))

  ((constantly 10) 1)
  ((constantly 10) 1 2 3 4)
  ((constantly 10) (+ 1 1))
#+END_SRC
* TODO Ajax
* Componentes de prueba
#+BEGIN_SRC clojure :exports none
  (def app-state (atom {:game "startrek"
                        :escenario nil
                        :bitacoras []}))

    (swap! app-state :escenario 2)
    ;; si hacemos esto se borra el estado original, desaparece :game
    ;; (swap! app-state :escenario {:titulo "pantalla yep"} )

    (swap! app-state assoc :escenario {:titulo "pantalla yep"} )

  (defn bitacoras []
    (get-in @app-state [:bitacoras]))

  (defn agregar-bitacora [bitacora]
    (swap! app-state
           assoc :bitacoras
           (conj (bitacoras) bitacora)))

  (->
   (bitacoras)
   (conj {:z 1}))

  (defn limpiar-bitacora []
    (swap! app-state assoc :bitacoras []))

  (limpiar-bitacora)

  (agregar-bitacora {:dia 3})

  (get-in @app-state [:bitacoras])

  (swap! app-state
         assoc :bitacoras
         (identity [{:a :b} {:c :d}]))

  (swap! app-state
         assoc :bitacoras
         (conj (get-in @app-state [:bitacoras]) {:x :y}))

  (conj (get-in @app-state [:bitacoras]) {:e :f})

  (swap! app-state
         assoc :escenario 5)

  (swap! app-state
         assoc :bitacoras
         )
  ;;
  ;; (conj (get-in @app-state [:bitacoras]) {:a})

  (get-in @app-state [:bitacoras])

  (def escenarios
    [{:nombre :sugerencias
      :titulo "Sugerencias del juego"
      :dialogo "¿Sabías el control de navegación que aparece debajo te da acceso completo a la nave espacial?"}
     {:nombre :explorar
      :titulo "Explorando nuevos mundos"
      :dialogo "Buscando posiblidad de nuevos mundos en las cercanías.."}
     {:nombre :mision
      :titulo "Misión infiltración"
      :dialogo "Tu misión es encontrar a los enemigos de la US Enterprise lo más pronto posible"}
     {:nombre :terminal
      :titulo "Terminal de Comando"
      :dialogo "> Terminal de comando de la USS Enterprise"}])

  (map #(% :dialogo) (get-in @app-state [:bitacoras]))

  (get-in @app-state [:bitacoras 0 :dialogo])

  (get-in @app-state [:bitacoras])

    (defn escenario-detalle [nombre]
      (filter #(= (% :nombre) nombre) escenarios))

    (escenario-detalle "inicio")

    escenarios

    (get-in escenarios [1 :titulo])
#+END_SRC
