#+TITLE: Recursividad
* for
** Conceptos
   - Generar todas las combinaciones posibles de múltiples secuencias recibidas sin varios niveles de anidamiento
   - Acepta el modificador ~:let~ para bindear/vincular valores
   - Acepta el modificador ~:when~ para filtrar que valores usará el cuerpo de for
   - Acepta el modificador ~:while~ para detener un ciclo de combinación (no todos, sólo un ciclo de combinaciones)

   #+BEGIN_QUOTE
   Diferencias entre los modificadores ~:when~ y ~:while~
   - ~:when~ filtrará los resultados que el ~for~ devuelve
   - ~:while~ detiene un ciclo de combinaciones (/resuta más fácil entenderlo al verlo en práctica/)
   #+END_QUOTE
** Ejemplos Básicos
*** Ejemplo 1
    #+BEGIN_SRC clojure
      ;; operamos entre elementos de una lista
      (for [x (list 1 2 3)
            y (list 1 2 3)]
        (* x y))

      ;; operamos entre elementos de un vector
      (for [x [1 2 3]
            y [1 2 3]]
        (* x y))

      ;; devolvemos pares ordenados de la forma [letra numero]
      (for [x ['a 'b 'c]
            y [1 2 3]]
        [x y])

      ;; devolvemos pares ordenados de la forma [numero numero]
      (for [x (range 3)
            y (range 3)]
        [x y])


      ;; :when
      ;; - si la condición se cumple, evalúa la expresión en el cuerpo de la función
      (for [x (range 3)
            y (range 3)
            :when (not= x y)]
        [x y])

      ;; :while
      ;; - si la condición se cumple, detiene la iteración del for
      (for [x (range 3)
            y (range 3)
            :while (not= x y)]
        [x y])
    #+END_SRC
*** Ejemplo 2 - for con modificadores :let :when y :while
    #+BEGIN_SRC clojure
      (for [n (range 100)
            :let [doble (* 2 n)]
            :when (even? n) ;; es par ?
            :while (< n 10)]
        (str "el doble de " n " es " doble))
    #+END_SRC
** Ejemplos
*** Ejemplo 1 - Multiples secuencias sin varios niveles de anidamiento
    #+BEGIN_SRC clojure
      ;; el for hará todas las posibles combinaciones entre los elementos
      ;; de cada secuencia (colores, materiales, tipos)
      (let [colores [:rojo :verde :amarillo]
            materiales [:tela :algodon]
            tipos [:remera :campera]]
        (for [color colores
              material materiales
              tipo tipos]
          [color material tipo]))
    #+END_SRC
*** Ejemplo 2 - for con modificador :while
    #+BEGIN_SRC clojure
      ;; el for recibe 3 secuencias de vectores
      ;; y generará todas las combinaciones posibles [color material tipo]
      ;;
      ;; 1. como :rojo != :verde, entonces devolverá todas las combinaciones [:rojo material tipo]
      ;; 2. como :verde = :verde el while detiene el flujo y no se evalúan mas combinaciones
      ;; incluso [:amarillo material tipo] porque el while estaba después de colores
      ;; y sólo evaluaba color
      (let [colores [:rojo :verde :amarillo]
            materiales [:tela :algodon]
            tipos [:remera :campera]]
        (for [color colores
              :while (not= color :verde)
              material materiales
              tipo tipos]
          [color material tipo]))
    #+END_SRC
*** Ejemplo 3 - for con modificador :while más en detalle
    #+BEGIN_SRC clojure
      ;; al pasarle tres secuencias x y z si no contemplamos el :while debería hacer [x y z]
      ;; es decir todas las combinaciones de los tres vectores
      ;;
      ;; hasta donde pondramos el :while es hasta donde evaluará y decide si cortar el flujo
      ;; hace combinaciones [x y] y si x!=y entonces hace [x y z] si no corta el flujo
      ;;
      ;;
      ;; empieza con [1 1] como x(1)=y(1) el while corta el flujo, no evalúa ninguna combinación [1 y]
      ;; por tanto no llega a evalúar [1 2 z] ni [1 3 z] porque ya salió del flujo con [1 1]
      ;;
      ;; contínua con las combinaciones [2 y]
      ;; empezando con [2 1] como x(2)!=y(1) evalúa [2 1 z] que sería [2 1 :a] [2 1 :b]
      ;; sigue [2 2] como x(2)=y(2) corta el flujo de combinaciones [2 2 z] filtrando [2 2 :a] [2 2 :b]
      (for [x [1 2 3]
            y [1 2 3]
            :while (not= x y)
            z [:a :b]]
        [x y z])

      ;; en dónde esté el :while indica cuantas posibles combinaciones antes de cortar el flujo
      ;; Ej. antes era [x y] si se cumpla x=y cortaba el flujo y no llegaba a evaluar [x y z]
      ;; Ej. ahora es [x y z] se llega a evaluar apesar de si se cumple x=y
      ;; filtrando sólo los x=y en [x y z] en vez de sólo [x y], habiendo mas combinaciones
      ;;
      ;; cuando se cumple x(1)=y(1) se corta el flujo sólo para las combinaciones [1 1 z]
      ;; pero permite el resto [1 2 z] y [1 3 z]
      (for [x [1 2 3]
            y [1 2 3]
            z [:a :b]
            :while (not= x y)]
        [x y z])
    #+END_SRC
*** Ejemplo 4 - for con más de un modificador :when
    #+BEGIN_SRC clojure
      ;; el for hará todas las posibles combinaciones entre los elementos
      ;; de cada secuencia (colores, materiales, tipos)
      ;;
      ;; pero filtrará las combinaciones q tengan la keyword :tela
      (let [colores [:rojo :verde :amarillo]
            materiales [:tela :algodon]
            tipos [:remera :campera]]
        (for [color colores
              material materiales
              tipo tipos
              :when (not= material :tela)]
          [color material tipo]))

      ;; filtrará las combinaciones q tengan la keyword :rojo ó :tela
      (let [colores [:rojo :verde :amarillo]
            materiales [:tela :algodon]
            tipos [:remera :campera]]
        (for [color colores
              material materiales
              tipo tipos
              :when (not= color :rojo)
              :when (not= material :tela)]
          [color material tipo]))
    #+END_SRC
** Referencias
   1. [[https://clojuredocs.org/clojure.core/for][for - clojure.core (clojuredocs.org)]]
*** Referencias
* Loop y Recur
** Conceptos
  - ~loop~ actúa como una función que recibe un argumento y es llamada sólo por ~recur~
  - ~loop~ bindea/vincula un valor a una variable
  - ~recur~ hace el llamado recursivo a ~loop~ pasandole un parámetro
  - Combinados ~loop~ y ~recur~
    1) generamos *recursivad de cola* (tail recursion), de forma menos verbosa que definir una *función recursiva*
    2) el compilador de clojure tiene optimizaciones para *recursividad de cola* ésta será más rápido y eficiente que una *función recursiva*

  #+BEGIN_QUOTE
  Every time a recursive function calls itself, it consumes a stack frame, and if it recurses too deeply,
  the JavaScript runtime will stop execution with an error.

  However, recursive processes written with ~loop~ and ~recur~ can recurse arbitrarily deeply because
  *the ClojureScript compiler is able to optimize them into an imperative loop*.
  For this reason, loop is also usually faster than functional recursion.

  By Andrew Meredith, Learn ClojureScript
  #+END_QUOTE
** Ejemplos
*** Ejemplo 1 - Contador con loop y recur
    #+BEGIN_SRC clojure
      ;; la recursividad finaliza cuando se cumple (> iteracion 3)
      (loop [iteracion 0]
        (println (str "Iterando.. " iteracion))
        (if (> iteracion 3)
          (println "Fin de la iteración")
          (recur (inc iteracion))))

      (loop [iteracion 0
             numeros []]
        (if (= iteracion 10)
          numeros
          (recur (inc iteracion) (conj numeros iteracion))))

      ;; Can only recur from tail position
      (loop [iteracion 0
             numeros []]
        (if (= iteracion 10)
          numeros
          (* iteracion (recur (inc iteracion) (conj numeros iteracion)))))
    #+END_SRC
*** Ejemplo 2 - Algoritmo de Euclides
   #+BEGIN_SRC clojure
     ;; algoritmo de euclides con recursividad normal
     (defn gcd [a b]
       (if (= b 0)
         a
         (gcd b (mod a b))))

     ;; algoritmo de euclides con loop y recur
     (defn gcd-own [a b]
       (loop [x a
              y b]
         (if (= y 0)
           x
           (recur y (mod x y)))))

     (gcd-own 90 60)
   #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://clojure.org/guides/learn/flow#_recursion][Clojure, Flow Control, Recursion (clojure.org)]]
*** Referencias Extra-Oficiales
    1. [[https://www.campusmvp.es/recursos/post/Recursividad-de-cola-tail-recursion.aspx][Recursividad de cola (campusmvp.es)]]
* Función Recursiva
** Conceptos
   - Con el concepto de *sobrecarga de aridad* podemos plantear un caso base y caso recursivo de una función

   #+BEGIN_QUOTE
   Un posible caso sería un contador que se ejecuta 4 veces
   1. si no recibe ningún parámetro, se llama asi misma pasandose por parámetro un valor (Ej. 0)
   2. si recibe un parámetro lo bindea/vincula a un nombre (Ej. iteracion)
      1. si no se cumple ~(> iteracion 3)~, hacemos la llamada recursiva pasandose como parámetro la variable iteracion incrementada en 1
      2. si se cumple ~(> iteracion 3)~, cortamos el flujo devolviendo la última expresión que queremos evaluar ~Ej.(println "fin..")~
   #+END_QUOTE
** Ejemplo
*** Ejemplo 1 - Contador recursivo
    #+BEGIN_SRC clojure
      ;; la recursividad finaliza cuando se cumple (> iteracion 3)
      (defn contar-recursivamente
        ([]
         (contar-recursivamente 0))

        ([iteracion]
         (println (str "Iterando.." iteracion))
         (if (> iteracion 3)
           (println "Fin de la iteración")
           (contar-recursivamente (inc iteracion)))))

      (contar-recursivamente)
    #+END_SRC
*** Ejemplo 2 - Algoritmo de Euclides
    #+BEGIN_QUOTE
    El algoritmo de euclides devuelve el mayor denominador entre dos números
    Por ejemplo ~(gcd 90 60) = 30~ porque
    1. ~(mod 90 60) = 30~ porque 90=60 * 1 + 30
    2. ~(mod 60 30) = 0~  porque 60=60 * 1 + 0, como tenemos cero, el 30 era el mayor denominador común entre 90 y 60
    #+END_QUOTE

   #+BEGIN_SRC clojure
     (defn gcd [a b]
       (if (= b 0)
         a
         (gcd b (mod a b))))

     (gcd 90 60)
   #+END_SRC
* Reduce
** Conceptos
   - ~reduce~ facilita iterar y aplicar funciones sobre una colección
   - ~reduce~ evita tener que definir *funciones recursivas* que requieren implementar el *caso base* y *caso recursivo*
   - ~reduce~ evita tener que definir funciones que usen ~loop~ y ~recur~ (/estas dos funciones son una mejor opción en vez definir una función recursiva/)
   - Usa el concepto de *sobrecarga de aridad* porque
     - Si le pasamos sólo dos parámetros ~función colección~ elegirá por defecto como *valor semilla* el *primer elemento de la colección*
     - Si le pasamos tres parámetros ~función semilla colección~ aplicará la función con la *semilla* y el *primer elemento de la colección*
** Ejemplos Básicos
*** Ejemplo 1 - Reduce con funciones anónimas
    #+BEGIN_SRC clojure
      ;; imprimirá sólo la semilla, el 1 (como no la definimos, eligió por defecto el 1º elemento del vector)
      (reduce
       (fn [resultado elemento]
         (println resultado))
       [1 2 3 4])

      ;; imprimirá la semilla (el 1) y devolverá 3 veces el string "BOO"
      (reduce
       (fn [resultado elemento]
         (println resultado)
         "BOOO!")
       [1 2 3 4])

      ;; imprimirá cada elemento excepto la semilla (2 3 4)
      (reduce
       (fn [resultado elemento] (println elemento))
       [1 2 3 4])

      ;; - definimos que la semilla será el 0, ya no será el 1
      ;; - imprimirá cada elemento (1 2 3 4)
      (reduce
       (fn [resultado elemento] (println elemento))
       0
       [1 2 3 4])

      ;; - imprime cada elemento
      ;; - aplica la función suma en el siguiente orden
      ;; 1. semilla (0) + primer elemento del vector (1)
      ;; 2. resultado anterior + siguiente elemento del vector
      ;; 3. la última expresión evaluada es el resultado de sumar todos los elementos
      ;; por tanto devolverá sólo un valor
      (reduce
       (fn [resultado elemento]
         (println (str "el elemento evaluado: " elemento))
         (+ resultado elemento))
       0
       [1 2 3 4])
    #+END_SRC
*** Ejemplo 2 - Reduce con funciones comunes
    #+BEGIN_SRC clojure
      ;; devuelve sólo un valor, la suma de todos los elementos de la colección
      ;; el resultado de (+ (+ (+ 1 2) 3) 4)
      (reduce + [1 2 3 4])

      ;; devuelve sólo un valor, pero al definir el 10 como semilla
      ;; el resultado devuelto será de (+ (+ (+ 10 1) 2) 3)
      (reduce + 10 [1 2 3])

      ;; devuelve sólo un string luego de evaluar (str (str "hola " "que ") " tal")
      ;; la cadena será "hola que tal"
      (reduce str ["hola " "que " "tal"])
    #+END_SRC
*** Ejemplo 3 - Reduce con el & rest parameter
    #+BEGIN_QUOTE
    Recordemos que el *rest parameter* se usa en las *funciones variádicas*,
    aquellas que reciben un número indefinido de argumentos y se usa de la forma ~& lista-argumentos~
    #+END_QUOTE

    #+BEGIN_SRC clojure
      (reduce
       (fn [& argumentos]
         (println "argumentos = " argumentos))
       [1 2 3 4 5])
    #+END_SRC
** Ejemplos - Implementando un Reducer
*** Ejemplo 1 - Implementando un reduce que obliga a pasarle la semilla
    #+BEGIN_QUOTE
    Simulamos un reduce pero obliga a pasarle un valor semilla,
    por lo general un reduce toma el primer elemento de la colección como semilla

    1. bindea/vincula la semilla a ~resultado~ y la colección a recorrer en ~elementos-pendientes~
    2. si ya no quedan elementos por evaluar, devuelve el ~resultado~
    3. si quedan elementos por evaluar hace el llamado recursivo a ~loop~ con ~recur~ pasandole dos parámetros
       - el 1º parámetro es el resultado de aplicar la funcion a dos elementos (/la semilla y primer elemento de la colección/)
       - el 2º parámetro los elementos restantes
    4. se repetirá paso 3 hasta que no queden más elementos, siendo ~resultado~ la última expresión evaluada y devuelta
    #+END_QUOTE

    #+BEGIN_SRC clojure
      (defn mi-reduce
        ([funcion semilla coleccion]
         (loop [resultado semilla
                elementos-pendientes coleccion]
           (if (empty? elementos-pendientes)
             resultado
             (recur (funcion resultado (first elementos-pendientes)) (rest elementos-pendientes))))))

      (mi-reduce + 0 [1 2 3 4])
    #+END_SRC
*** Ejemplo 2 - Implementando un reduce que elige sólo la semilla
    :PROPERTIES:
    :ID:       3be05d09-1ed9-4cda-8239-c54c6014d294
    :END:
    #+BEGIN_QUOTE
    Aplicamos *sobrecarga de aridad* porque

    1. podemos pasarle un valor semilla, será el primer valor que se aplicará con el primer elemento de la colección
    2. si no le pasamos el valor la semilla, usará el concepto de *destructuring* y elegiremos como semilla la cabeza de la colección
       y luego hará una *llamada recursiva* al reduce
    #+END_QUOTE

    #+BEGIN_SRC clojure
      (defn mi-reduce
        ([funcion semilla coleccion]
         (loop [resultado semilla
                elementos-pendientes coleccion]
           (if (empty? elementos-pendientes)
             resultado
             (recur (funcion resultado (first elementos-pendientes)) (rest elementos-pendientes)))))
        ([funcion [cabeza & cola]]
         (mi-reduce funcion cabeza cola)))

      (mi-reduce + [1 2 3 4])
      (mi-reduce + 0 [1 2 3 4])
    #+END_SRC
** Referencias
*** Referencias Extra-oficiales
    1. [[https://levelup.gitconnected.com/reducers-in-clojure-c088a5627412][Reducers in Clojure (By Functional Human)]]
    2. [[https://ericnormand.me/article/a-reduce-example-explained][A reduce example explained (ericnormand.me)]]

