#+TITLE: Recursividad
* Loop y Recur
** Conceptos
  - Permiten la recursividad, y es menos verboso que definir una *función recursiva*
  - ~loop~ actúa como una función que recibe un argumento y es llamada sólo por ~recur~
  - ~loop~ bindea/vincula un valor a una variable
  - ~recur~ hace el llamado recursivo a ~loop~ pasandole un parámetro
** Ejemplos
*** Ejemplo 1 - Contador con loop y recur
    #+BEGIN_SRC clojure
      ;; la recursividad finaliza cuando se cumple (> iteracion 3)
      (loop [iteracion 0]
        (println (str "Iterando.. " iteracion))
        (if (> iteracion 3)
          (println "Fin de la iteración")
          (recur (inc iteracion))))
    #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://clojure.org/guides/learn/flow#_recursion][Clojure, Flow Control, Recursion (clojure.org)]]
* Función Recursiva
** Conceptos
   - Con el concepto de *sobrecarga de aridad* podemos plantear un caso base y caso recursivo de una función

   #+BEGIN_QUOTE
   Un posible caso sería un contador que se ejecuta 4 veces
   1. si no recibe ningún parámetro, se llama asi misma pasandose por parámetro un valor (Ej. 0)
   2. si recibe un parámetro lo bindea/vincula a un nombre (Ej. iteracion)
      1. si no se cumple ~(> iteracion 3)~, hacemos la llamada recursiva pasandose como parámetro la variable iteracion incrementada en 1
      2. si se cumple ~(> iteracion 3)~, cortamos el flujo devolviendo la última expresión que queremos evaluar ~Ej.(println "fin..")~
   #+END_QUOTE
** Ejemplo
*** Ejemplo 1 - Contador recursivo
    #+BEGIN_SRC clojure
      ;; la recursividad finaliza cuando se cumple (> iteracion 3)
      (defn contar-recursivamente
        ([]
         (contar-recursivamente 0))

        ([iteracion]
         (println (str "Iterando.." iteracion))
         (if (> iteracion 3)
           (println "Fin de la iteración")
           (contar-recursivamente (inc iteracion)))))

      (contar-recursivamente)
    #+END_SRC
* Reducer
** Ejemplos
*** Ejemplo 1 - Implementando un reduce que obliga a pasarle la semilla
    #+BEGIN_QUOTE
    Simulamos un reduce pero obliga a pasarle un valor semilla,
    por lo general un reduce toma el primer elemento de la colección como semilla

    1. bindea/vincula la semilla a ~resultado~ y la colección a recorrer en ~elementos-pendientes~
    2. si ya no quedan elementos por evaluar, devuelve el ~resultado~
    3. si quedan elementos por evaluar hace el llamado recursivo a ~loop~ con ~recur~ pasandole dos parámetros
       - el 1º parámetro es el resultado de aplicar la funcion a dos elementos (/la semilla y primer elemento de la colección/)
       - el 2º parámetro los elementos restantes
    4. se repetirá paso 3 hasta que no queden más elementos, siendo ~resultado~ la última expresión evaluada y devuelta
    #+END_QUOTE

    #+BEGIN_SRC clojure
      (defn mi-reduce
        ([funcion semilla coleccion]
         (loop [resultado semilla
                elementos-pendientes coleccion]
           (if (empty? elementos-pendientes)
             resultado
             (recur (funcion resultado (first elementos-pendientes)) (rest elementos-pendientes))))))

      (mi-reduce + 0 [1 2 3 4])
    #+END_SRC
*** Ejemplo 2 - Implementando un reduce que elige sólo la semilla
    #+BEGIN_QUOTE
    Aplicamos *sobrecarga de aridad* porque

    1. podemos pasarle un valor semilla, será el primer valor que se aplicará con el primer elemento de la colección
    2. si no le pasamos el valor la semilla, usará el concepto de *destructuring* y elegiremos como semilla la cabeza de la colección
       y luego hará una *llamada recursiva* al reduce
    #+END_QUOTE

    #+BEGIN_SRC clojure
      (defn mi-reduce
        ([funcion semilla coleccion]
         (loop [resultado semilla
                elementos-pendientes coleccion]
           (if (empty? elementos-pendientes)
             resultado
             (recur (funcion resultado (first elementos-pendientes)) (rest elementos-pendientes)))))
        ([funcion [cabeza & cola]]
         (mi-reduce funcion cabeza cola)))

      (mi-reduce + [1 2 3 4])
      (mi-reduce + 0 [1 2 3 4])
    #+END_SRC
** Referencias
*** Referencias Extra-oficiales
    1. [[https://ericnormand.me/article/a-reduce-example-explained][A reduce example explained (ericnormand.me)]]
