#+TITLE: Estructuras de datos
* Maps
  #+BEGIN_SRC clojure
    ;; map vacío
    {}


    ;; :apodo :fuerza :velocidad se denominan "keywords"
    {:apodo "neverkas" :fuerza 100 :velocidad 300}

    ;; (nested maps) podemos anidar maps dentro de otro map
    {:nombre "picard" :habilidades {:velocidad 100 :fuerza 100}}

    ;; error
    ;;{hash-map :a 1 :b 3}

    ;; get
    ;; - obtener el valor de una keyword
    (get {:nombre "picard" :rango "capitan"} :rango)

    (get {:nombre "picard" :habilidades {:velocidad 100 :fuerza 100}} :habilidades)

    ;; acceder a maps anidados
    (get-in {:nombre "picard" :habilidades {:velocidad 100 :fuerza 100}} [:habilidades :velocidad])
  #+END_SRC
* Keywords
  #+BEGIN_SRC clojure
    ;; las keywords pueden utilizar como funciones
    ;; en este caso actúa como si hubieramos usado la función (get :nombre)
    (:nombre {:nombre "picard" :rango "capitan"})

    ;; si usamos las keywords como funciones
    ;; podemos asignarle un valor default
    (:habilidades {:nombre "picard" :rango "capitan"} "no tiene habilidades")
  #+END_SRC
* Vectores
  #+BEGIN_SRC clojure
    ;; vector con 3 elementos
    [3 2 1]

    ;; vector puede tener cualquier tipo de dato como elemento
    ;; (Ej. numeros, strings, funciones, maps, ...)
    [3 "zombie" 1 (+ 1 9) {:nombre "picard" :rango "capitan"}]

    ;; get
    ;; - funciona similar que con los maps
    ;; - indicamos el índice/posición del elemento en el vector
    (get [3 2 1] 0)

    ;; conj
    ;; - agrega un elemento al final del vector
    (conj [3 2 1] 0)
  #+END_SRC
* Listas
  #+BEGIN_SRC clojure
    ;; lista con 3 elementos
    ;; pero no los evalúa, se entenderá ésta característica al comparar con (list)
    (quote (3 2 1))

    ;; manera abreviada a usar (quote)
    '(3 2 1)

    ;; lista con 3 elementos
    (list 3 2 1)

    ;; pueden contener cualquier tipo de dato
    ;; al usar (quote) no se evaluará la función (+ 1 2)
    '(1 "samu" (+ 1 2))

    ;; list permite evaluar la función (+ 1 2)
    (list 1 "samu" (+ 1 2))

    ;; nth
    ;; - para obtener un elemento de una lista (es menos eficiente comparado con el get en vectores)
    ;; - no confundir con (get) ese sirve para vectores
    (nth '(1 2 3) 0)

    (nth '(:nombre :rango ) 1)

    ;; conj
    ;; - para agregar un elemento al principio de la lista
    ;; - en los vectores los agrega al final
    (conj '(3 2 1) 4)
  #+END_SRC
* Set - Colección sin elementos duplicados
  #+BEGIN_SRC clojure
    ;; set
    ;; - crea una colección sin elementos duplicados
    (set [3 3 3 3 1 1])

    ;; otra forma de crear un set
    #{"picard" 33 :velocidad}

    ;; conj
    ;; - agrega elementos al final del Set
    (conj #{1 2} 9)

    ;; pero si ya existe no lo agrega
    (conj #{1 2} 2)

    ;; contains?
    ;; - para consultar la existencia ó no de un elemento por su valor,
    ;; - las funciones con ? al final devuelven un valor booleano
    (contains? #{3 2 1} 9)
  #+END_SRC



