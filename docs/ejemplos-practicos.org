* Un Androide Simétrico
** Ejemplo 1 - Aplicando recursividad con loop y recur
   #+BEGIN_QUOTE
   Una explicación muy general de la función ~cuerpo-androide-simetrico~ sería..
   1. bindeamos/vinculamos el vector de map en ~componentes-pendientes~
      y bindeamos un vector vacío a ~cuerpo-simetrico~ que iremos agregando componentes en los llamados recursivos
   2. mientras haya componentes sin revisar, aplicamos el concepto de *destructuring* en ~componentes-pendientes~
      para separar la cabeza ~componente-revisado~ y la cola ~resto-componentes~ (/aunque éste sea un vector, clojure lo permite/)
   3. hacemos el llamado recursivo pasando la cola ~resto-componentes~ como parámetro
      que volverá a aplicarse *destructuring* hasta no quedar elementos
   4. agregamos en el vector ~cuerpo-simetrico~ cada ~componente-revisado~
      y aplica nuestra función de simetría si el patrón de la regex coincide devolviendo el componente simétrico faltante
   5. agregamos los componentes creando un ~set~ para evitar que los elementos que no coincidan con la regex estén repetidos
     (/Ej. cabeza, naríz/)
   #+END_QUOTE

  #+BEGIN_SRC clojure
    (def androide-cuerpo-asimetrico [{:nombre "cabeza" :size 3}
                                     {:nombre "ojo-izquierdo" :size 1}
                                     {:nombre "pierna-izquierda" :size 4}
                                     {:nombre "brazo-izquierdo" :size 4}
                                     {:nombre "hombro-izquierdo" :size 1}
                                     {:nombre "boca" :size 1}
                                     {:nombre "nariz" :size 1}])

    (defn componente-cibernetico-simetrico
      [componente]
      {:nombre (clojure.string/replace (:nombre componente) #"-izquierd(.)$" "-derech$1")
       :size (:size componente)})

    (defn androide-cuerpo-simetrico
      "Espera un vector de map con :nombre y :size"
      [componentes-cuerpo-asimetrico]
      (loop [componentes-pendientes componentes-cuerpo-asimetrico
             cuerpo-simetrico []]
        (if (empty? componentes-pendientes)
          cuerpo-simetrico
          (let [[componente-revisado & resto-componentes] componentes-pendientes]
            (recur resto-componentes
                   (into cuerpo-simetrico
                         (set [componente-revisado (componente-cibernetico-simetrico componente-revisado)])))))))

    (androide-cuerpo-simetrico androide-cuerpo-asimetrico)
  #+END_SRC
** Ejemplo 2 - Usando reduce
  #+BEGIN_SRC clojure
    (def androide-cuerpo-asimetrico [{:nombre "cabeza" :size 3}
                                     {:nombre "ojo-izquierdo" :size 1}
                                     {:nombre "pierna-izquierda" :size 4}
                                     {:nombre "brazo-izquierdo" :size 4}
                                     {:nombre "hombro-izquierdo" :size 1}
                                     {:nombre "boca" :size 1}
                                     {:nombre "nariz" :size 1}])

    (defn componente-cibernetico-simetrico
      [componente]
      {:nombre (clojure.string/replace (:nombre componente) #"-izquierd(.)$" "-derech$1")
       :size (:size componente)})

    ;; - la función pasada como primer parámetro al reduce, se aplica primero sobre la semilla
    ;; (ó sobre el primer elemento de la colección si no se la definimos) y luego en cada elemento de la colección
    ;; - la función insert devuelve una colección (ó un vector, será de tipo donde insertamos elementos)

    ;; lógica aplicada en el reduce
    ;; 1. definimos una función anónima que usará la semilla del reduce como un vector
    ;; (ya teniendo en mente que el reduce tendrá como semilla un vector vacío, que será pasado como segundo parámetro)
    ;; 2. la función anónima agregará en el vector un Set con cada componente y su componente simétrico si lo tuviese
    ;; (si no usaramos Set agregaría dos veces los componentes que no tienen un simétrico, Ej. cabeza, boca, nariz)
    (defn androide-cuerpo-simetrico
      "Espera un vector de map con :nombre y :size"
      [componentes-cuerpo-asimetrico]
      (reduce (fn [cuerpo-simetrico componente]
                (into cuerpo-simetrico (set [componente (componente-cibernetico-simetrico componente)])))
              []
              componentes-cuerpo-asimetrico))

    (androide-cuerpo-simetrico androide-cuerpo-asimetrico)
  #+END_SRC
** Referencias
   1. https://memory-alpha.fandom.com/es/wiki/Data
* TODO Alienigenas con simetría radial
  #+BEGIN_COMMENT
  falta seguir...
  #+END_COMMENT

 #+BEGIN_SRC clojure
   (def alien-imperfecto [{:nombre "cabeza" :size 3}
                          {:nombre "ojo-izquierdo" :size 1}
                          {:nombre "pie-izquierda" :size 4}
                          {:nombre "tentaculo-izquierdo" :size 4}
                          {:nombre "boca" :size 1}
                          {:nombre "nariz" :size 1}])

   ;; TODO: utilizar repeat ó similar, queremos evitar la típica iteración for que reutiliza la posición
   ;; Simetría pentámera: Simetría radial basada en 5 o múltiplos de él (Ej. en los equinodermos)
   (defn cuerpo-simetria-radial
     [componente]
     {:nombre (clojure.string/replace (:nombre componente) #"-izquierd(.)$" "-derech$1") :size (:size componente)})

   (defn alien-completar-cuerpo
     "Espera un vector de map con :nombre y :size"
     [alien-cuerpo-imperfecto]
     (reduce (fn [alien-cuerpo-perfecto parte]
               (into alien-cuerpo-perfecto (set [parte (cuerpo-simetria-radial parte)])))
             []
             alien-cuerpo-imperfecto))

   (alien-completar-cuerpo alien-imperfecto)
 #+END_SRC
* Ataque contra Androides Malvados
** Ejemplo
   #+BEGIN_SRC clojure
     (def androide-malvado-asimetrico [{:nombre "cabeza" :size 3}
                                      {:nombre "ojo-izquierdo" :size 1}
                                      {:nombre "pierna-izquierda" :size 4}
                                      {:nombre "brazo-izquierdo" :size 4}
                                      {:nombre "hombro-izquierdo" :size 1}
                                      {:nombre "boca" :size 1}
                                      {:nombre "nariz" :size 1}])

     (defn componente-cibernetico-simetrico
       [componente]
       {:nombre (clojure.string/replace (:nombre componente) #"-izquierd(.)$" "-derech$1")
        :size (:size componente)})

     (defn androide-cuerpo-simetrico
       "Espera un vector de map con :nombre y :size"
       [componentes-cuerpo-asimetrico]
       (reduce (fn [cuerpo-simetrico componente]
                 (into cuerpo-simetrico (set [componente (componente-cibernetico-simetrico componente)])))
               []
               componentes-cuerpo-asimetrico))

     (androide-cuerpo-simetrico androide-malvado-asimetrico)

     (defn atacar
       [androide-cuerpo-asimetrico]
       (let [cuerpo-simetrico (androide-cuerpo-simetrico androide-cuerpo-asimetrico)
             size-total-cuerpo (reduce + (map :size cuerpo-simetrico))
             componente-objetivo (rand size-total-cuerpo)]
         (loop [[componente-analizado & componentes-pendientes] cuerpo-simetrico
                size-componente-analizado (:size componente-analizado)]
           (if (> size-componente-analizado componente-objetivo)
             componente-analizado
             (recur componentes-pendientes (+ size-componente-analizado (:size (first componentes-pendientes))))))))

     (atacar androide-malvado-asimetrico)
   #+END_SRC
* Generador de Contadores
** Generador de Contadores Incrementales
  #+BEGIN_SRC clojure
    ;; ésta función que devuelve una función anónima,
    ;; que espera recibir un argumento
    (defn generador-contador-incremental
      "Crea un contador incremental personalizado"
      [incrementar-en]
      (fn [num] (+ num incrementar-en)))

    ;; bindeamos/vinculamos al contador una función nombrada
    ;; pero que devuelve una función anónima que espera recibir un argumento
    (def incrementar-en-5 (generador-contador-incremental 5))

    ;; le estamos pasando el valor 1 a la función anónima
    (incrementar-en-5 1)
  #+END_SRC

** Generador de Contadores Decrecrementales
  #+BEGIN_SRC clojure
    (defn generador-contador-decremental
      "Crea un contador incremental personalizado"
      [decrementar-en]
      (fn [num] (- num decrementar-en)))

    (def decrementar-en-2 (generador-contador-decremental 2))

    (decrementar-en-2 4)
  #+END_SRC
* Mapset
  #+BEGIN_SRC clojure
    ;; los primeros reduce son a modo de práctica
    ;; para luego entender el mapset

    ;; devuelve un valor
    (reduce (fn [resultado elemento]
              (+ resultado elemento))
            0
            [1 2 3 4])

    ;; devuelve un set (colección con elementos sin repetir)
    (reduce (fn [resultado elemento]
              (into resultado [elemento]))
            #{}
            [1 1 3 1])

    (defn mapset
      [f coleccion]
      (reduce (fn [resultado elemento]
                (into resultado [(f elemento)]))
              #{}
              coleccion))

    (mapset inc [1 1 2 2])
  #+END_SRC

