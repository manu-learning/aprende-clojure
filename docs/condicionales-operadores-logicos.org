#+TITLE: Condicionales + Operadores lógicos/relacionales
* Control de Flujo
** Condicional Simple - if
*** Conceptos
    - la sintáxis es de la forma ~(if predicado rama-if rama-else)~
    - la ~rama-else~ es opcional y no es necesario definir con una palabra clave
      (/en otros lenguajes es necesario usar la palabra clave else/)

    #+BEGIN_QUOTE
    El primer parámetro del ~if~ es un *predicado* (/una función booleana/)
    según si se cumple ó no, evaluará la expresión que tenga la ~rama-if~ ó ~rama-else~

    El *predicado* se considera que se cumple si devuelve un valor diferente a ~false~ ó ~nil~
    por tanto no necesariamente debe devolver ~true~ para que se evalúe la ~rama-if~
    #+END_QUOTE
*** Ejemplos Básico
**** Ejemplo 1 - Escenarios donde se cumple el predicado (función booleana)
    #+BEGIN_SRC clojure
      ;; en éste caso podriamos como no hay una rama-else
      ;; podríamos haber usado la macro when
      (if true
        "Se cumplió la condición!")

      (when true
        "Se cumplió la condición!")

      ;; devolverá la primera cadena
      (if true
        "Se cumplió la condición!"
        "algo no salió bien :(")

      ;; devolverá la primera cadena
      ;; porque 1 no es nil ni tampoco false
      (if 1
        "Se cumplió la condición!"
        "algo no salió bien :(")

      ;; éste puede parecer raro pero para que se entienda
      ;; que con devolver un valor diferente a nil ó false
      ;; es suficiente para evaluar la rama-if
      (if {:nombre "carlos"}
        "Se cumplió la condición!"
        "algo no salió bien :(")
    #+END_SRC
**** Ejemplo 2 - Escenarios donde no se cumple el predicado (función booleana)
    #+BEGIN_SRC clojure
      ;; devolverá la segunda cadena
      (if false
        "Se cumplió la condición!"
        "algo no salió bien :(")

      ;; devolverá la segunda cadena
      (if nil
        "Se cumplió la condición!"
        "algo no salió bien :(")

      ;; devolverá nil, porque falta la rama-else
      (if false
        "nil? pucha que hicimos mal?")

      ;; devolverá nil, porque falta la rama-else
      (if nil
        "nil? pucha que hicimos mal?")
    #+END_SRC
** Condicional Simple if + do
*** Conceptos
    - ~do~ evalúa una serie de expresiones
    - ~do~ extiende la funcionalidad del condicional ~if~ que sólo evaluaba una expresión en cada rama

    #+BEGIN_QUOTE
    Podemos pensar la cantidad de expresiones evaluadas por ~if~ ó ~do~ como *elementos de una lista*
    dónde cada rama del ~if~ sólo permite 1 elemento y ~do~ lo extiende para que admita más elementos
    #+END_QUOTE
*** Ejemplo Básico
    #+BEGIN_SRC clojure
    (if true
      (do (println "Bien..!")
          "se cumplió la condición :o")
      (do (println "Mal..!")
          "algo no salió bien :("))
    #+END_SRC
** Condicional when
*** Conceptos
    - ~when~ NO tiene una rama ~else~, evalúa las expresiones contenidas en el cuerpo de la función sólo si se cumple el *predicado*
    - ~when~ es una combinación entre
      1) ~if~ valida si cumple o no el *predicado* pasado como primer parámetro
      2) ~do~ extiende la cantidad de expresiones que se puede evaluar
*** Ejemplo
    #+BEGIN_SRC clojure
      ;; when
      ;; - actúa como el if + do
      ;; - no contiene la rama else
      (when (= 1 1)
        (println "Se cumplió la condición! :)")
        (println "Vamos por buen camino (?)")
        "sip")
    #+END_SRC
** when-let
*** Conceptos
    - la sintáxis es de la forma ~(when-let predicado-binding & cuerpo)~
    - el primer parámetro ~predicado-binding~
      1) primero se evalúa un *predicado* (/función booleana/)
      2) si se cumple el *predicado* entonces *se vincula/bindea el resultado a un nombre* de variable
    - el segundo parámetro ~& cuerpo~
      1) es el mismo concepto que el *parameter rest* porque al usar el símbolo ~&~ acepta un número indefinido de parámetros
      2) el *conjunto de parámetros* representa el *cuerpo de la función* ~when-let~
*** Ejemplos
**** Ejemplo 1 - Obtener primer mensaje no leido
    #+BEGIN_SRC clojure
      (def correo-juan {:mensajes [{:id 100 :leido? true}
                                   {:id 101 :leido? true}
                                   {:id 102 :leido? false}
                                   {:id 103 :leido? false}
                                   {:id 105 :leido? true}]})

      (defn primer-mensaje-no-leido [correo]
        (->> (:mensajes correo)
             (filter (comp not :leido?))
             (first)))

      (defn leer-primer-mensaje-no-leido [correo]
        (when-let [mensaje (primer-mensaje-no-leido correo)]
          (dissoc mensaje :leido?)))

      ;; alternativa, si que queremos mantener toda la lógica junta
      (defn leer-primer-mensaje-no-leido* [correo]
        (when-let [mensaje (->> (:mensajes correo)
                                (filter (comp not :leido?))
                                (first))]
          (dissoc mensaje :leido?)))

      (primer-mensaje-no-leido correo-juan)
      (leer-primer-mensaje-no-leido correo-juan)

      (leer-primer-mensaje-no-leido* correo-juan)
    #+END_SRC
**** Ejemplo 2
     #+BEGIN_SRC clojure
       (def correo-mati {:mensajes []
                         :proximo-id 1})

       (def correo-juan {:mensajes [{:id 100 :leido? false :texto "Saludos a familia"}
                                    {:id 101 :leido? false :texto "Pedido de tarea"}
                                    {:id 102 :leido? false :texto "Saludos a un amigo"}]
                         :proximo-id 103})

       (defn siguiente-mensaje-no-leido [correo]
         (when-let [mensaje (->> (:mensajes correo)
                                 (filter (comp not :leido?))
                                 first)]
           (dissoc mensaje :leido?)))

       ;; test
       (= 100 (:id (siguiente-mensaje-no-leido correo-juan)))

       (siguiente-mensaje-no-leido correo-juan)
       (siguiente-mensaje-no-leido correo-mati)

       ;; por convención.. las funciones que terminan con el símbolo ! de exclamación
       ;; son las que modifican el estado del objeto y devuelven un objeto nuevo
       (defn marcar-mensaje-como-leido! [correo id]
         (update correo :mensajes (fn [mensajes]
                                    (map #(if (= id (:id %)) (assoc % :leido? true) %)
                                         mensajes))))

       ;; TODO: test
       (marcar-mensaje-como-leido! correo-juan 101)

       ;; por convención.. las funciones que terminan con el símbolo ! de exclamación
       ;; son las que modifican el estado del objeto y devuelven un objeto nuevo
       (defn leer-todos-los-mensajes! [correo]
         (loop [mensajes-pendientes correo]
           (when-let [mensaje-leido (siguiente-mensaje-no-leido mensajes-pendientes)]
             (println (:texto mensaje-leido))
             (recur
              (marcar-mensaje-como-leido mensajes-pendientes (:id mensaje-leido))))))

       ;; test
       (nil? (leer-todos-los-mensajes correo-juan))
     #+END_SRC
** Condicional if-let
*** Conceptos
    - vincula a un nombre de variable un valor si se cumple un predicado
      (/NO puede vincular más de un nombre de variable/)
    - ~if-let~ es una combinación entre
      1. ~if~ para validar si se cumple ó no un *predicado* (función booleana) y también tiene la *rama else*
      2. ~let~ para vincular/bindear a un nombre de variable si el *predicado* es distinto a ~nil~ ó ~false~ (/por tanto es true u otro valor que no sea nil ó false/)
*** Ejemplo Básico
    #+BEGIN_SRC clojure
      ;; suponiendo que no sabíamos que existe "if-let"...
      ;; 1. con let vinculamos/bindeamos el valor al nombre de la variable
      ;; 2. con if validamos si su valor es distinto de nil ó false
      (defn confirmar-suscripcion [persona]
        (let [email (:email persona)]
          (if email
            (str "Te enviaremos un correo a " email)
            "Error")))

      (confirmar-suscripcion {:nombre "Riker" :email "riker@gmail.com"})
      (confirmar-suscripcion {:nombre "Riker"})

      ;; con if-let nos facilita lo anterior
      ;; pero..! sólo podemos vincular/bindear un nombre
      (defn confirmar-registro [persona]
        (if-let [email (:email persona)]
          (str "Te enviaremos un correo a " email)
          "Error"))

      (confirmar-registro {:nombre "Riker" :email "riker@gmail.com"})
      (confirmar-registro {:nombre "Riker"})
    #+END_SRC
** nil?
*** Conceptos
    - ~nil?~ es un *predicado* que evalúa si una expresión representa el valor ~nil~
    - ~nil~ en otros lenguajes se conoce por ~NULL~ ó *valor nulo*
    - ~nil~ es el resultado de que una *expresión-s* no tiene un valor vinculado ó que una función genera *side-effect*
*** Ejemplo Básico
  #+BEGIN_SRC clojure
    (nil? 1)
    (nil? nil)

    (if nil
      "esta cadena no se imprimirá porque no es nil se trata como un false"
      "nil actúa similar al false")
  #+END_SRC
* Operadores lógicos y relacionales
** Operador Lógico OR
*** Conceptos
    - evalúa de izquierda a derecha (/por tanto el orden de las expresiones que ponemos a evaluar es importante/)
    - si alguna expresion es verdadera (es ~true~ ó devuelve ~true~), entonces deja de evaluar de izq. a der. y *devuelve el primero que sea verdadero*
    - si ninguna expresión es verdadera (ninguna es true ó devuelve true), entonces *devuelve la última expresión*

    #+BEGIN_QUOTE
    ~or~ NO es una *función* es una *macro*,
    para usarla con la función ~map~ debemos encapsularla dentro de una *función anónima*
    por ejemplo ~(map #(or %1 %2) [true false] [false false])~
    #+END_QUOTE
*** Ejemplos Básicos
**** Ejemplo 1 - OR devuelve la primera expresión que no es false
     #+BEGIN_SRC clojure
       ;; devolverá :fuerza
       (or false nil :fuerza :velocidad)

       ;; devolverá 99
       (or false nil false 99)

       ;; devolverá 99
       (or 99 nil :fuerza true :velocidad)
     #+END_SRC
**** Ejemplo 2 - OR devuelve la última expresión si todas son false
     #+BEGIN_SRC clojure
       ;; devolverá false
       (or nil false)

       ;; devolverá nil
       (or false nil)

       ;; devolverá false, que es el valor de retorno de la última expresión (= "pedrito" "carlitos")
       (or (= 0 9) (= "pedrito" "carlitos"))
     #+END_SRC
*** Ejemplos
**** Ejemplo 1
     #+BEGIN_SRC clojure
       ;; devolverá (true false)
       (map #(or %1 %2) [true false] [false false])

       ;; devolverá (true 99)
       (map #(or %1 %2) [true false] [false 99])

       ;; devolverá (:velocidad 99)
       (map #(or %1 %2) [:velocidad false] [false 99])
     #+END_SRC
**** Ejemplo 2 - Combinando OR con la función incremental inc
     #+BEGIN_SRC clojure
       ;; devuelve el resultado de 1+1
       (inc 1)

       ;; devuelve el resultado 0+1
       ;; porque para OR si al menos uno no es falso, entonces devuelve la última expresión
       (inc (or false nil 0))
     #+END_SRC
**** Ejemplo 3 - Combinando OR con la función update-in que actualiza estructuras asociativas
     #+BEGIN_SRC clojure
       ;; una estructura map vacía sólo contiene a la expresión nil (hace referencia al valor vacío en éste caso al conjunto vacío)
       (first {})

       ;; devuelve una copia de la estructura con la edad incrementada en 1
       (update-in {:edad 21 :nombre "pepe"} [:edad] inc)

       ;; devuelve {:velocidad 1}
       ;; 1. al no encontrar la keyword :velocidad la agrega a una copia de la estructura map vacía {}
       ;; 2. el OR devuelve 0 porque el % de la función anónima #() obtiene el valor de la función :velocidad y ésta devuelve nil porque no tiene un valor asociado
       ;; (la macro OR, devuelve la primera expresión que no sea ó devuelva false ó nil)
       ;; 3. inc incrementa el valor 0 devuelto por OR, evaluando (inc 0) que resulta en 1
       (update-in {} [:velocidad] #(inc (or % 0)))

       ;; mismo resultado que el anterior porque :velocidad tiene asociado el valor nil
       ;; por tanto el OR devolverá el 0 (cero) y luego la función inc hará 0+1
       ;; actualizando el valor de la keyword :velocidad de nil a 1 (uno)
       ;; en una nueva estructura map
       (update-in {:velocidad nil} [:velocidad] #(inc (or % 0)))

       ;; devuelve {:velocidad 3}
       ;; la diferencia con el anterior es que..
       ;; 1. en el OR el % de la función anónima #() obtiene el valor de la función :velocidad y éste es 2
       ;; 2. inc incrementa el valor 2 obtenido por % quedando (inc 2)
       (update-in {:velocidad 2} [:velocidad] #(inc (or % 0)))

       ;; devuelve {:velocidad nil}
       ;; porque el % de la función anónima #() obtiene el valor de :velocidad que es nil
       ;; porque no es una keyword incluida en map
       (update-in {} [:velocidad] #(or %))

       ;; - usar % ó %1 es lo mismo
       ;; - con %1 obtenemos el primer parámetro que es :velocidad
       (update-in {:velocidad 2} [:velocidad] #(inc (or %1 0)))

       ;; otro ejemplo no relacionado a lo anterior..
       ;; pero para recordar, que podemos usar update-in para estructuras map anidadas
       (update-in {:habilidades {:velocidad 100}} [:habilidades :velocidad] inc)
     #+END_SRC
** Operador Lógico AND
*** Conceptos
    - si todos los valores son verdaderos, devuelve el último
    - si alguno no es verdadero, devuelve el primero que sea falso
*** Ejemplos Básicos
    #+BEGIN_SRC clojure
      ;; devuelve :velocidad
      (and :fuerza :velocidad)

      ;; devuelve nil
      (and :fuerza nil false)
    #+END_SRC
** Operadores relacionales
*** Ejemplos Básicos
  #+BEGIN_SRC clojure
    ;; =
    ;; - operador de igualdad
    (= 1 1)
    (= nil nil)
    (= 1 2)
  #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://clojuredocs.org/clojure.core/or][or - clojure.core (clojuredocs.org)]]
    2. [[https://clojuredocs.org/clojure.core/update-in][update-in, clojure.core (clojuredocs.org)]]
