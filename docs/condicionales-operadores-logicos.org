#+TITLE: Condicionales + Operadores lógicos/relacionales
* TODO Control de Flujo
** Condicional Simple - if
*** Conceptos
*** Ejemplo
    #+BEGIN_SRC clojure
    ;; if
    ;; - el segundo parámetro es la rama if, se evalúa si se cumple la condición
    ;; - el tercer parámetro es al rama else, se evalúa si NO se cumple la condición
    (if true
      "se cumplió la condición!"
      "algo no salió bien :(")

    (if false
      "nil? pucha que hicimos mal?")
    #+END_SRC
** Condicional Simple if + do
*** Ejemplo
    #+BEGIN_SRC clojure
    ;; do
    ;; - encapsula lógica de varias acciones
    ;; - útil para el condicional if, que por defecto sólo ejecuta 1 acción en caso de éxito/fracaso
    (if true
      (do (println "Bien..!")
          "se cumplió la condición :o")
      (do (println "Mal..!")
          "algo no salió bien :("))
    #+END_SRC
** Condicional when
*** Conceptos
*** Ejemplo
    #+BEGIN_SRC clojure
    ;; when
    ;; - actúa como el if + do
    ;; - no contiene la rama else
    (when true
      (println "Se cumplió la condición! :)")
      "vamos por buen camino")
    #+END_SRC
** Condicional if-let
*** Conceptos
    - vincula a un nombre de variable un valor si se cumple un predicado
      (/NO puede vincular más de un nombre de variable/)
    - ~if-let~ es una combinación entre
      1. ~if~ para validar si se cumple ó no un *predicado* (función booleana) y también tiene la *rama else*
      2. ~let~ para vincular/bindear a un nombre de variable si el *predicado* es distinto a ~nil~ ó ~false~ (/por tanto es true u otro valor que no sea nil ó false/)
*** Ejemplo Básico
    #+BEGIN_SRC clojure
      ;; suponiendo que no sabíamos que existe "if-let"...
      ;; 1. con let vinculamos/bindeamos el valor al nombre de la variable
      ;; 2. con if validamos si su valor es distinto de nil ó false
      (defn confirmar-suscripcion [persona]
        (let [email (:email persona)]
          (if email
            (str "Te enviaremos un correo a " email)
            "Error")))

      (confirmar-suscripcion {:nombre "Riker" :email "riker@gmail.com"})
      (confirmar-suscripcion {:nombre "Riker"})

      ;; con if-let nos facilita lo anterior
      ;; pero..! sólo podemos vincular/bindear un nombre
      (defn confirmar-registro [persona]
        (if-let [email (:email persona)]
          (str "Te enviaremos un correo a " email)
          "Error"))

      (confirmar-registro {:nombre "Riker" :email "riker@gmail.com"})
      (confirmar-registro {:nombre "Riker"})
    #+END_SRC
** nil?
*** Ejemplo
  #+BEGIN_SRC clojure
    ;; nil
    ;; - en otros lenguajes se conoce por NULL
    ;; - es el resultado de que una expresión-s no tiene un valor asignado
    ;; - una buena práctica sería usar la función (nil? sexp) en vez del if
    (nil? 1)
    (nil? nil)

    (if nil
      "esta cadena no se imprimirá porque no es nil se trata como un false"
      "nil actúa similar al false")
  #+END_SRC
* Operadores lógicos y relacionales
** Operador Lógico OR
*** Conceptos
    - evalúa de izquierda a derecha (/por tanto el orden de las expresiones que ponemos a evaluar es importante/)
    - si alguna expresion es verdadera (es ~true~ ó devuelve ~true~), entonces deja de evaluar de izq. a der. y *devuelve el primero que sea verdadero*
    - si ninguna expresión es verdadera (ninguna es true ó devuelve true), entonces *devuelve la última expresión*

    #+BEGIN_QUOTE
    ~or~ NO es una *función* es una *macro*,
    para usarla con la función ~map~ debemos encapsularla dentro de una *función anónima*
    por ejemplo ~(map #(or %1 %2) [true false] [false false])~
    #+END_QUOTE
*** Ejemplos Básicos
**** Ejemplo 1 - OR devuelve la primera expresión que no es false
     #+BEGIN_SRC clojure
       ;; devolverá :fuerza
       (or false nil :fuerza :velocidad)

       ;; devolverá 99
       (or false nil false 99)

       ;; devolverá 99
       (or 99 nil :fuerza true :velocidad)
     #+END_SRC
**** Ejemplo 2 - OR devuelve la última expresión si todas son false
     #+BEGIN_SRC clojure
       ;; devolverá false
       (or nil false)

       ;; devolverá nil
       (or false nil)

       ;; devolverá false, que es el valor de retorno de la última expresión (= "pedrito" "carlitos")
       (or (= 0 9) (= "pedrito" "carlitos"))
     #+END_SRC
*** Ejemplos
**** Ejemplo 1
     #+BEGIN_SRC clojure
       ;; devolverá (true false)
       (map #(or %1 %2) [true false] [false false])

       ;; devolverá (true 99)
       (map #(or %1 %2) [true false] [false 99])

       ;; devolverá (:velocidad 99)
       (map #(or %1 %2) [:velocidad false] [false 99])
     #+END_SRC
**** Ejemplo 2 - Combinando OR con la función incremental inc
     #+BEGIN_SRC clojure
       ;; devuelve el resultado de 1+1
       (inc 1)

       ;; devuelve el resultado 0+1
       ;; porque para OR si al menos uno no es falso, entonces devuelve la última expresión
       (inc (or false nil 0))
     #+END_SRC
**** Ejemplo 3 - Combinando OR con la función update-in que actualiza estructuras asociativas
     #+BEGIN_SRC clojure
       ;; una estructura map vacía sólo contiene a la expresión nil (hace referencia al valor vacío en éste caso al conjunto vacío)
       (first {})

       ;; devuelve una copia de la estructura con la edad incrementada en 1
       (update-in {:edad 21 :nombre "pepe"} [:edad] inc)

       ;; devuelve {:velocidad 1}
       ;; 1. al no encontrar la keyword :velocidad la agrega a una copia de la estructura map vacía {}
       ;; 2. el OR devuelve 0 porque el % de la función anónima #() obtiene el valor de la función :velocidad y ésta devuelve nil porque no tiene un valor asociado
       ;; (la macro OR, devuelve la primera expresión que no sea ó devuelva false ó nil)
       ;; 3. inc incrementa el valor 0 devuelto por OR, evaluando (inc 0) que resulta en 1
       (update-in {} [:velocidad] #(inc (or % 0)))

       ;; mismo resultado que el anterior porque :velocidad tiene asociado el valor nil
       ;; por tanto el OR devolverá el 0 (cero) y luego la función inc hará 0+1
       ;; actualizando el valor de la keyword :velocidad de nil a 1 (uno)
       ;; en una nueva estructura map
       (update-in {:velocidad nil} [:velocidad] #(inc (or % 0)))

       ;; devuelve {:velocidad 3}
       ;; la diferencia con el anterior es que..
       ;; 1. en el OR el % de la función anónima #() obtiene el valor de la función :velocidad y éste es 2
       ;; 2. inc incrementa el valor 2 obtenido por % quedando (inc 2)
       (update-in {:velocidad 2} [:velocidad] #(inc (or % 0)))

       ;; devuelve {:velocidad nil}
       ;; porque el % de la función anónima #() obtiene el valor de :velocidad que es nil
       ;; porque no es una keyword incluida en map
       (update-in {} [:velocidad] #(or %))

       ;; - usar % ó %1 es lo mismo
       ;; - con %1 obtenemos el primer parámetro que es :velocidad
       (update-in {:velocidad 2} [:velocidad] #(inc (or %1 0)))

       ;; otro ejemplo no relacionado a lo anterior..
       ;; pero para recordar, que podemos usar update-in para estructuras map anidadas
       (update-in {:habilidades {:velocidad 100}} [:habilidades :velocidad] inc)
     #+END_SRC
** Operador Lógico AND
*** Conceptos
    - si todos los valores son verdaderos, devuelve el último
    - si alguno no es verdadero, devuelve el primero que sea falso
*** Ejemplos Básicos
    #+BEGIN_SRC clojure
      ;; devuelve :velocidad
      (and :fuerza :velocidad)

      ;; devuelve nil
      (and :fuerza nil false)
    #+END_SRC
** Operadores relacionales
*** Ejemplos Básicos
  #+BEGIN_SRC clojure
    ;; =
    ;; - operador de igualdad
    (= 1 1)
    (= nil nil)
    (= 1 2)
  #+END_SRC
** Referencias
*** Referencias Oficiales
    1. [[https://clojuredocs.org/clojure.core/or][or - clojure.core (clojuredocs.org)]]
    2. [[https://clojuredocs.org/clojure.core/update-in][update-in, clojure.core (clojuredocs.org)]]
